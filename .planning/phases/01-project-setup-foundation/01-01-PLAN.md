---
phase: 01-project-setup-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - .gitignore
  - .env.example
  - packages/shared/package.json
  - packages/shared/tsconfig.json
  - packages/shared/src/types/index.ts
  - packages/shared/src/types/tool.ts
  - packages/shared/src/types/api.ts
  - packages/shared/src/constants/index.ts
  - packages/shared/src/constants/tools.ts
  - packages/shared/src/utils/index.ts
  - packages/shared/src/index.ts
  - packages/server/package.json
  - packages/server/tsconfig.json
  - packages/server/src/index.ts
  - packages/server/src/config/env.ts
  - packages/server/src/types/errors.ts
  - packages/server/src/middleware/errorHandler.ts
  - packages/server/src/routes/health.ts
  - packages/server/.env
  - packages/server/.env.example
  - packages/server/vitest.config.ts
  - packages/server/src/__tests__/health.test.ts
  - packages/server/src/__tests__/errorHandler.test.ts
autonomous: true

must_haves:
  truths:
    - "TypeScript monorepo compiles without errors via tsc --build"
    - "Express server starts and responds to GET /api/health with JSON status"
    - "Environment variables load from .env with typed config object"
    - "Error responses distinguish user errors (4xx, isOperational:true) from system errors (5xx, isOperational:false)"
    - "Shared types are importable from server package via @repo/shared"
  artifacts:
    - path: "package.json"
      provides: "Root monorepo config with npm workspaces"
      contains: "workspaces"
    - path: "tsconfig.json"
      provides: "Root TypeScript project references"
      contains: "references"
    - path: "packages/shared/src/types/tool.ts"
      provides: "Tool type definitions shared across packages"
      exports: ["Tool", "ToolStatus", "ToolCategory"]
    - path: "packages/shared/src/types/api.ts"
      provides: "API response envelope types"
      exports: ["ApiResponse", "ApiError"]
    - path: "packages/server/src/index.ts"
      provides: "Express server entry point"
      min_lines: 30
    - path: "packages/server/src/types/errors.ts"
      provides: "Custom error classes for INFRA-04"
      exports: ["AppError", "UserError", "SystemError"]
    - path: "packages/server/src/middleware/errorHandler.ts"
      provides: "Express error handling middleware"
      exports: ["errorHandler"]
    - path: "packages/server/src/routes/health.ts"
      provides: "Health check endpoint"
      exports: ["default"]
  key_links:
    - from: "packages/server/src/index.ts"
      to: "packages/server/src/middleware/errorHandler.ts"
      via: "app.use(errorHandler) as last middleware"
      pattern: "app\\.use\\(errorHandler\\)"
    - from: "packages/server/src/index.ts"
      to: "packages/server/src/routes/health.ts"
      via: "app.use('/api', healthRouter)"
      pattern: "healthRouter|health"
    - from: "packages/server/src/routes/health.ts"
      to: "packages/server/src/config/env.ts"
      via: "imports config for environment info"
      pattern: "import.*config"
    - from: "packages/server/tsconfig.json"
      to: "packages/shared/tsconfig.json"
      via: "TypeScript project reference"
      pattern: "references.*shared"
    - from: "packages/server/src/types/errors.ts"
      to: "packages/shared/src/types/api.ts"
      via: "error response matches ApiError shape"
      pattern: "ApiError|type.*error"
---

<objective>
Create the monorepo skeleton with npm workspaces, the shared types package, and the Express server with health check and error handling.

Purpose: Establishes the foundational project structure that all subsequent phases build upon. Delivers INFRA-04 (clear error messages distinguishing user vs system errors) and the core compilation pipeline.

Output: Compilable TypeScript monorepo with working Express server, shared types, health endpoint, and error handling middleware.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-project-setup-foundation/01-CONTEXT.md
@.planning/phases/01-project-setup-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Monorepo skeleton and shared types package</name>
  <files>
    package.json
    tsconfig.json
    .gitignore
    .env.example
    packages/shared/package.json
    packages/shared/tsconfig.json
    packages/shared/src/types/index.ts
    packages/shared/src/types/tool.ts
    packages/shared/src/types/api.ts
    packages/shared/src/constants/index.ts
    packages/shared/src/constants/tools.ts
    packages/shared/src/utils/index.ts
    packages/shared/src/index.ts
  </files>
  <action>
    Create root package.json:
    - name: "@repo/root" (private: true)
    - workspaces: ["packages/*"]
    - engines: { "node": ">=22.0.0" }
    - scripts: build, build:clean, dev, test, lint, format, typecheck
    - No dependencies at root level initially (devDependencies only: typescript)

    Create root tsconfig.json:
    - files: [] (solution-style, no direct compilation)
    - references: [packages/client, packages/server, packages/shared]

    Create .gitignore:
    - node_modules, dist, .env (not .env.example), coverage, .DS_Store, *.log, .idea, .vscode (except settings shared)

    Create .env.example at root with comment pointing to packages/server/.env.example for server config.

    Create packages/shared/package.json:
    - name: "@repo/shared"
    - version: "0.0.0"
    - type: "module"
    - main: "./dist/index.js", types: "./dist/index.d.ts"
    - exports: { ".": { "types": "./dist/index.d.ts", "import": "./dist/index.js" }, "./types": { "types": "./dist/types/index.d.ts", "import": "./dist/types/index.js" } }
    - scripts: build ("tsc --build"), clean ("tsc --build --clean")
    - No runtime dependencies

    Create packages/shared/tsconfig.json:
    - composite: true (CRITICAL for project references)
    - declaration: true, declarationMap: true
    - outDir: "./dist", rootDir: "./src"
    - strict: true, esModuleInterop: true, skipLibCheck: true
    - moduleResolution: "bundler", target: "ES2022", module: "ESNext"
    - include: ["src/**/*"], exclude: ["dist", "node_modules"]

    Create packages/shared/src/types/tool.ts:
    - ToolStatus type: "available" | "in-development" | "coming-soon"
    - ToolCategory type: "transpiler" | "verification" | "linter"
    - ToolLanguage type: string literal union of supported languages ("cpp", "c", "rust", "csharp", "java", "python", "typescript", "bash")
    - Tool interface: { id: string; name: string; description: string; status: ToolStatus; category: ToolCategory; sourceLanguage: ToolLanguage; targetLanguage?: ToolLanguage; }

    Create packages/shared/src/types/api.ts:
    - ApiErrorType: "user_error" | "system_error"
    - ApiError: { type: ApiErrorType; message: string; details?: Record<string, unknown> }
    - ApiResponse<T>: { data: T } | { error: ApiError }
    - HealthResponse: { status: "ok"; timestamp: number; uptime: number; environment: string; version: string; }

    Create packages/shared/src/types/index.ts: barrel export re-exporting all types from tool.ts and api.ts.

    Create packages/shared/src/constants/tools.ts:
    - TOOLS array of Tool objects matching the 8 tools from PROJECT.md (C++ to C Transpiler, C++ to Rust Transpiler, C# Verification, Java Verification, Rust Verification, Python Linter, TypeScript Linter, Bash Verification)
    - Each with accurate status matching PROJECT.md context table

    Create packages/shared/src/constants/index.ts: barrel export re-exporting from tools.ts.

    Create packages/shared/src/utils/index.ts: empty barrel (placeholder for future utilities).

    Create packages/shared/src/index.ts: barrel export re-exporting everything from types, constants, utils.

    Run: npm install at root to initialize workspaces and create package-lock.json.
    Run: cd packages/shared && npm run build to verify compilation.
    Verify .d.ts files appear in packages/shared/dist/.
  </action>
  <verify>
    Run `npm run build -w @repo/shared` from project root -- must succeed with no errors.
    Verify packages/shared/dist/index.js and packages/shared/dist/index.d.ts exist.
    Verify packages/shared/dist/types/tool.d.ts exports Tool, ToolStatus, ToolCategory.
  </verify>
  <done>
    Shared package compiles, produces .js and .d.ts outputs, and all 8 tool definitions match PROJECT.md.
  </done>
</task>

<task type="auto">
  <name>Task 2: Express server with health check and error handling (INFRA-04)</name>
  <files>
    packages/server/package.json
    packages/server/tsconfig.json
    packages/server/src/index.ts
    packages/server/src/config/env.ts
    packages/server/src/types/errors.ts
    packages/server/src/middleware/errorHandler.ts
    packages/server/src/routes/health.ts
    packages/server/.env
    packages/server/.env.example
    packages/server/vitest.config.ts
    packages/server/src/__tests__/health.test.ts
    packages/server/src/__tests__/errorHandler.test.ts
  </files>
  <action>
    Create packages/server/package.json:
    - name: "@repo/server"
    - version: "0.0.0"
    - type: "module"
    - main: "./dist/index.js"
    - scripts: dev ("tsx watch src/index.ts"), build ("tsc --build"), start ("node dist/index.js"), test ("vitest run"), "test:watch" ("vitest")
    - dependencies: express (^4.x), cors (^2.x), dotenv (^16.x), helmet (^8.x), express-async-errors (^3.x), @repo/shared ("*")
    - devDependencies: tsx (^4.x), @types/express (^4.x), @types/cors (^2.x), vitest (^3.x), supertest (^7.x), @types/supertest (^6.x)

    Create packages/server/tsconfig.json:
    - composite: true
    - outDir: "./dist", rootDir: "./src"
    - strict: true, esModuleInterop: true, skipLibCheck: true
    - moduleResolution: "bundler", target: "ES2022", module: "ESNext"
    - references: [{ "path": "../shared" }]
    - include: ["src/**/*"], exclude: ["dist", "node_modules", "src/__tests__"]

    Create packages/server/src/config/env.ts:
    - Import dotenv and call config() at top
    - Export typed config object with: nodeEnv (string, default "development"), port (number, default 3000), logLevel (string, default "info"), version (string, from package.json or env)
    - Use `as const` for type narrowing
    - Validate required env vars at import time (throw if missing critical ones -- none required in phase 1, but structure the validation pattern)

    Create packages/server/src/types/errors.ts:
    - AppError class extending Error: constructor(statusCode: number, message: string, isOperational: boolean = true). Set Object.setPrototypeOf for proper instanceof checks. Include optional `details` field (Record<string, unknown>).
    - UserError class extending AppError: constructor(message, statusCode = 400). Always isOperational = true.
    - SystemError class extending AppError: constructor(message, statusCode = 500). Always isOperational = false.
    - NotFoundError class extending UserError: constructor(resource: string). Message = `${resource} not found`, statusCode = 404.
    - ValidationError class extending UserError: constructor(message, details). statusCode = 422.

    Create packages/server/src/middleware/errorHandler.ts:
    - Import AppError from types/errors, ApiError from @repo/shared
    - Error handler middleware (4-arg Express signature: err, req, res, next)
    - If err instanceof AppError: respond with { error: { type: isOperational ? "user_error" : "system_error", message: err.message, details: err.details } }, status = err.statusCode
    - If unknown error: log full error with console.error, respond with 500 { error: { type: "system_error", message: "An unexpected error occurred" } }
    - NEVER expose stack traces or internal details in system_error responses
    - Log all errors (user_error at warn level, system_error at error level)

    Create packages/server/src/routes/health.ts:
    - Express Router with GET /health
    - Returns HealthResponse from @repo/shared: { status: "ok", timestamp: Date.now(), uptime: process.uptime(), environment: config.nodeEnv, version: config.version }

    Create packages/server/src/index.ts:
    - Import express-async-errors at very top (before any Express imports) -- this patches Express 4 for async error propagation
    - Import express, cors, helmet
    - Create Express app
    - Middleware order: helmet(), cors(), express.json({ limit: "100mb" }), express.urlencoded({ extended: true })
    - Mount routes: app.use("/api", healthRouter)
    - Error handler LAST: app.use(errorHandler)
    - In dev mode (isDev): log that Vite middleware will be added in Plan 02
    - In production: placeholder comment for static file serving (Plan 02)
    - Listen on config.port, log startup message
    - Export app for testing

    Create packages/server/.env with NODE_ENV=development, PORT=3000, LOG_LEVEL=debug.
    Create packages/server/.env.example with same keys but placeholder values.

    Create packages/server/vitest.config.ts:
    - name: "server", environment: "node", globals: true
    - include: ["src/__tests__/**/*.test.ts"]

    Create packages/server/src/__tests__/health.test.ts:
    - Use supertest to test GET /api/health
    - Assert 200 status, response body has status: "ok", timestamp (number), uptime (number), environment (string)

    Create packages/server/src/__tests__/errorHandler.test.ts:
    - Test UserError returns 4xx with type: "user_error" and the error message
    - Test SystemError returns 5xx with type: "system_error" and generic message (not internal details)
    - Test unknown Error returns 500 with type: "system_error"
    - Test NotFoundError returns 404 with type: "user_error"
    - Test ValidationError returns 422 with type: "user_error" and details

    Run: npm install from root to install all server dependencies.
    Run: npm run build (root) to build shared + server via tsc --build.
    Run: npm run test -w @repo/server to execute tests.
  </action>
  <verify>
    1. `npm run build` from root succeeds (both shared and server compile).
    2. `npm run test -w @repo/server` -- all tests pass.
    3. `npm run dev -w @repo/server` starts server, then `curl http://localhost:3000/api/health` returns JSON with status: "ok".
    4. Kill dev server after verification.
  </verify>
  <done>
    Express server compiles, starts, responds to /api/health, and error handling returns proper user_error vs system_error responses (INFRA-04 satisfied). All server tests pass.
  </done>
</task>

</tasks>

<verification>
- `npm run build` from project root compiles all packages (shared + server) without errors
- `npm run test -w @repo/server` passes all tests (health endpoint + error handler)
- `curl http://localhost:3000/api/health` returns `{ "status": "ok", ... }`
- Server import of `@repo/shared` types works at compile time and runtime
- Error responses follow `{ error: { type: "user_error"|"system_error", message: string } }` format
</verification>

<success_criteria>
- TypeScript project references chain (root -> server -> shared) compiles via `tsc --build`
- Health endpoint returns correct JSON structure
- Error middleware correctly classifies UserError (4xx) vs SystemError (5xx)
- All server unit tests pass
- Shared types are properly exported and importable
</success_criteria>

<output>
After completion, create `.planning/phases/01-project-setup-foundation/01-01-SUMMARY.md`
</output>
