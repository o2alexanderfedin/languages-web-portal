---
phase: 04-real-time-output-streaming
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/shared/src/types/streaming.ts
  - packages/shared/src/types/index.ts
  - packages/server/src/services/streamService.ts
  - packages/server/src/routes/stream.ts
  - packages/server/src/routes/execute.ts
  - packages/server/src/index.ts
  - packages/server/package.json
  - packages/server/src/__tests__/streamService.test.ts
  - packages/server/src/__tests__/stream.test.ts
  - packages/server/src/__tests__/execute.test.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "POST /api/execute returns jobId immediately without blocking until completion"
    - "GET /api/stream/:jobId establishes SSE connection with keep-alive heartbeats"
    - "Subprocess stdout/stderr lines are forwarded to SSE session as 'output' events in real-time"
    - "SSE 'complete' event is sent with full ExecutionResponse when job finishes"
    - "Each job's SSE session is isolated by jobId (no cross-contamination)"
    - "SSE sessions are cleaned up on client disconnect and job completion"
  artifacts:
    - path: "packages/shared/src/types/streaming.ts"
      provides: "StreamEvent type definitions (output, complete, error, heartbeat)"
      contains: "StreamOutputEvent"
    - path: "packages/server/src/services/streamService.ts"
      provides: "SSE session management per jobId"
      exports: ["StreamService", "streamService"]
    - path: "packages/server/src/routes/stream.ts"
      provides: "GET /api/stream/:jobId SSE endpoint"
      contains: "createSession"
    - path: "packages/server/src/routes/execute.ts"
      provides: "Non-blocking POST /api/execute returning jobId"
      contains: "streamService"
  key_links:
    - from: "packages/server/src/routes/execute.ts"
      to: "packages/server/src/services/streamService.ts"
      via: "onOutput callback -> streamService.sendOutput(jobId, line)"
      pattern: "streamService\\.sendOutput"
    - from: "packages/server/src/routes/stream.ts"
      to: "packages/server/src/services/streamService.ts"
      via: "registerSession(jobId, session)"
      pattern: "streamService\\.registerSession"
    - from: "packages/server/src/routes/execute.ts"
      to: "packages/server/src/services/streamService.ts"
      via: "sendComplete after job finishes"
      pattern: "streamService\\.sendComplete"
---

<objective>
Server-side SSE streaming infrastructure: StreamService for managing per-job SSE sessions, SSE route endpoint, and execute route transformation from synchronous to non-blocking with streaming callbacks.

Purpose: Transform the Phase 3 synchronous request-response execution flow into a two-phase async pattern where POST /api/execute returns a jobId immediately and subprocess output streams in real-time to SSE-connected clients.

Output: Working SSE endpoint at GET /api/stream/:jobId, non-blocking POST /api/execute, StreamService singleton, shared streaming types, comprehensive test suite.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-real-time-output-streaming/04-RESEARCH.md
@.planning/phases/03-process-execution-sandboxing/03-02-SUMMARY.md
@packages/shared/src/types/execution.ts
@packages/server/src/services/executionService.ts
@packages/server/src/routes/execute.ts
@packages/server/src/services/queueService.ts
@packages/server/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Streaming types, StreamService, SSE route, and execute route transformation</name>
  <files>
    packages/shared/src/types/streaming.ts
    packages/shared/src/types/index.ts
    packages/server/src/services/streamService.ts
    packages/server/src/routes/stream.ts
    packages/server/src/routes/execute.ts
    packages/server/src/index.ts
    packages/server/package.json
  </files>
  <action>
    1. Install better-sse on server: `npm install better-sse -w @repo/server`

    2. Create `packages/shared/src/types/streaming.ts` with typed SSE event definitions:
       - `StreamOutputEvent`: `{ event: 'output'; data: { line: string; timestamp: number } }`
       - `StreamCompleteEvent`: `{ event: 'complete'; data: ExecutionResponse }`
       - `StreamErrorEvent`: `{ event: 'error'; data: { message: string } }`
       - `StreamEvent = StreamOutputEvent | StreamCompleteEvent | StreamErrorEvent`
       - Export all types

    3. Update `packages/shared/src/types/index.ts` to re-export streaming types:
       - Add `export * from './streaming.js';`

    4. Create `packages/server/src/services/streamService.ts`:
       - Import `Session` type from `better-sse`
       - Class `StreamService` with private `sessions: Map<string, Session>`
       - `registerSession(jobId: string, session: Session): void` - stores session in map
       - `unregisterSession(jobId: string): void` - removes session from map
       - `async sendOutput(jobId: string, line: string): Promise<void>` - pushes `output` event with `{ line, timestamp: Date.now() }` via `session.push()`. No-op if session not found.
       - `async sendComplete(jobId: string, result: ExecutionResponse): Promise<void>` - pushes `complete` event with result, then deletes session from map. No-op if session not found. Do NOT call session.close() here (let the client disconnect naturally after receiving complete).
       - `async sendError(jobId: string, message: string): Promise<void>` - pushes `error` event, then deletes session from map.
       - `hasSession(jobId: string): boolean` - check if session exists (useful for testing/debugging)
       - `get activeSessionCount(): number` - returns sessions.size
       - Export singleton `streamService`

    5. Create `packages/server/src/routes/stream.ts`:
       - Express Router with `GET /stream/:jobId`
       - Validate jobId is a non-empty string (return 400 if invalid)
       - Import `createSession` from `better-sse`
       - Create SSE session: `const session = await createSession(req, res, { keepAlive: 30000 })` (30s heartbeat)
       - Register session: `streamService.registerSession(jobId, session)`
       - Listen for client disconnect: `req.on('close', () => streamService.unregisterSession(jobId))`
       - Export router as default

    6. Transform `packages/server/src/routes/execute.ts`:
       - Import `streamService` from `../services/streamService.js`
       - CHANGE the POST /execute handler to be NON-BLOCKING:
         a. Keep validation logic (toolId, projectId, projectPath resolution) the same
         b. Generate jobId with uuidv4() as before
         c. Return `res.json({ data: { jobId } })` IMMEDIATELY (before execution starts)
         d. AFTER responding, queue the job: `queueService.addJob(async () => { ... })`
         e. Inside the queued job: call `executionService.executeJob({ toolId, projectPath, jobId, onOutput: (line) => streamService.sendOutput(jobId, line) })`
         f. After executeJob completes, call `await streamService.sendComplete(jobId, result)` to push final result to SSE client
         g. On error in the queued job, call `await streamService.sendError(jobId, error.message)` so the SSE client knows something went wrong
         h. Return result from the queued closure (for queueService job duration tracking)
       - IMPORTANT: Do not `await` the queueService.addJob call. Fire-and-forget so the response returns immediately. Use `.catch()` to log errors: `queueService.addJob(async () => { ... }).catch((err) => console.error('Job error:', err))`
       - Keep GET /queue/status unchanged

    7. Register stream router in `packages/server/src/index.ts`:
       - Import `streamRouter from './routes/stream.js'`
       - Add `app.use('/api', streamRouter)` alongside other API routes

    Build and verify: `npm run build` must pass with no TypeScript errors.
  </action>
  <verify>
    Run `npm run build` from project root - must compile with 0 errors.
    Run `npx eslint packages/server/src packages/shared/src --ext .ts` - must pass with 0 errors.
  </verify>
  <done>
    - better-sse installed in server package.json
    - Shared streaming types exported from @repo/shared
    - StreamService manages SSE sessions by jobId with register/unregister/send methods
    - GET /api/stream/:jobId creates SSE session with 30s heartbeat
    - POST /api/execute returns { data: { jobId } } immediately, queues execution in background
    - Execution output streamed to SSE via onOutput callback
    - Complete event sent when job finishes
    - Stream router registered in Express app
    - TypeScript builds cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: Comprehensive tests for StreamService, stream route, and updated execute route</name>
  <files>
    packages/server/src/__tests__/streamService.test.ts
    packages/server/src/__tests__/stream.test.ts
    packages/server/src/__tests__/execute.test.ts
  </files>
  <action>
    1. Create `packages/server/src/__tests__/streamService.test.ts` with tests:
       - "registerSession stores session and hasSession returns true"
       - "unregisterSession removes session and hasSession returns false"
       - "sendOutput calls session.push with output event format" (mock Session with push: vi.fn())
       - "sendOutput is no-op when session not found" (does not throw)
       - "sendComplete calls session.push with complete event and removes session"
       - "sendError calls session.push with error event and removes session"
       - "activeSessionCount reflects registered sessions"
       - Use fresh StreamService instance per test (not the singleton) for isolation
       - Mock Session objects: `{ push: vi.fn().mockResolvedValue(undefined) } as unknown as Session`

    2. Create `packages/server/src/__tests__/stream.test.ts` with tests:
       - Test the GET /stream/:jobId endpoint via supertest
       - NOTE: SSE endpoints are long-lived connections. Testing SSE with supertest requires special handling:
         a. "returns 400 for empty jobId" - test `GET /api/stream/` returns 400 (this is the route not matching, so likely 404 - adjust assertion accordingly, or test with query param validation)
         b. "returns SSE content-type header" - make request to `/api/stream/test-job-id`, check response starts with `Content-Type: text/event-stream`. Use supertest `.get()` but be aware the connection stays open. Use `.buffer(false)` and abort after checking headers.
         c. If SSE testing via supertest proves too complex for the connection lifecycle, SKIP SSE-specific tests in this file and note that SSE behavior is covered by streamService unit tests + integration testing. Focus on validation edge cases only.

    3. Update `packages/server/src/__tests__/execute.test.ts` to test the new non-blocking behavior:
       - Existing tests should be updated to expect `{ data: { jobId: expect.any(String) } }` response (not the full ExecutionResponse)
       - "POST /execute returns jobId immediately" - verify response contains `data.jobId` as a UUID string
       - "POST /execute returns 200 without blocking" - verify response returns quickly (no 60s timeout)
       - Keep existing validation tests (missing toolId, missing projectId, empty values)
       - Keep GET /queue/status test unchanged
       - Mock executionService.executeJob to avoid actual subprocess execution
       - Mock streamService.sendOutput and streamService.sendComplete to verify they are called

    Run all server tests: `npm test --workspace=@repo/server` must pass.
    Run ESLint: must pass with 0 errors.
  </action>
  <verify>
    Run `npm test --workspace=@repo/server` - all tests pass (existing + new).
    Run `npx eslint packages/server/src --ext .ts` - 0 errors.
  </verify>
  <done>
    - StreamService unit tests cover register, unregister, sendOutput, sendComplete, sendError, activeSessionCount
    - Stream route tests cover validation edge cases
    - Execute route tests updated for non-blocking response format (returns jobId, not full ExecutionResponse)
    - All server tests pass
    - ESLint clean
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes with 0 TypeScript errors
2. `npm test --workspace=@repo/server` passes all tests
3. `npx eslint packages/server/src packages/shared/src --ext .ts` passes with 0 errors
4. Manually verify (if dev server running): `curl -X POST http://localhost:3000/api/execute -H 'Content-Type: application/json' -d '{"toolId":"cpp-to-c","projectId":"test"}' ` returns `{ "data": { "jobId": "..." } }` immediately
5. Manually verify SSE: `curl -N http://localhost:3000/api/stream/some-job-id` returns SSE headers and heartbeat comments
</verification>

<success_criteria>
- POST /api/execute returns { data: { jobId } } immediately (non-blocking)
- GET /api/stream/:jobId establishes SSE connection with 30s heartbeat
- StreamService routes output/complete/error events to correct SSE session by jobId
- All server tests pass (existing updated + new streaming tests)
- TypeScript and ESLint clean
</success_criteria>

<output>
After completion, create `.planning/phases/04-real-time-output-streaming/04-01-SUMMARY.md`
</output>
