---
phase: 04-real-time-output-streaming
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - packages/client/src/hooks/useSSE.ts
  - packages/client/src/features/execution/ConsoleView.tsx
  - packages/client/src/features/execution/ExecutionPanel.tsx
  - packages/client/src/features/execution/executionApi.ts
  - packages/client/package.json
  - packages/client/src/__tests__/useSSE.test.tsx
  - packages/client/src/__tests__/ConsoleView.test.tsx
  - packages/client/src/__tests__/ExecutionPanel.test.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User sees real-time output lines appearing one-by-one in console view as tool runs"
    - "User sees ANSI color codes rendered as colored HTML (not raw escape sequences)"
    - "Console view auto-scrolls to bottom as new lines arrive"
    - "User sees spinner/progress indicator during execution"
    - "User sees execution metrics after completion (duration, exit code, status badge)"
    - "EventSource connection is properly cleaned up on component unmount"
    - "SSE connection errors are handled gracefully with user-visible feedback"
  artifacts:
    - path: "packages/client/src/hooks/useSSE.ts"
      provides: "EventSource lifecycle management hook"
      exports: ["useSSE"]
    - path: "packages/client/src/features/execution/ConsoleView.tsx"
      provides: "ANSI-aware streaming console renderer"
      exports: ["ConsoleView"]
    - path: "packages/client/src/features/execution/ExecutionPanel.tsx"
      provides: "Updated execution panel with streaming integration"
      exports: ["ExecutionPanel"]
  key_links:
    - from: "packages/client/src/features/execution/ExecutionPanel.tsx"
      to: "packages/client/src/hooks/useSSE.ts"
      via: "useSSE(jobId, onOutput, onComplete, onError)"
      pattern: "useSSE\\("
    - from: "packages/client/src/features/execution/ExecutionPanel.tsx"
      to: "packages/client/src/features/execution/ConsoleView.tsx"
      via: "ConsoleView receives streaming lines array"
      pattern: "<ConsoleView"
    - from: "packages/client/src/hooks/useSSE.ts"
      to: "/api/stream/:jobId"
      via: "new EventSource(`/api/stream/${jobId}`)"
      pattern: "EventSource.*api/stream"
    - from: "packages/client/src/features/execution/ConsoleView.tsx"
      to: "ansi_up"
      via: "AnsiUp.ansi_to_html for ANSI-to-HTML conversion"
      pattern: "ansi_to_html"
---

<objective>
Client-side SSE streaming UI: useSSE hook for EventSource lifecycle, ConsoleView component for ANSI-aware real-time output rendering, and ExecutionPanel transformation from synchronous to streaming execution flow.

Purpose: Users see real-time subprocess output streaming line-by-line in a styled console view with ANSI color support, progress indicators during execution, and execution metrics after completion.

Output: Working streaming console in browser, useSSE hook, ConsoleView component, updated ExecutionPanel, comprehensive test suite.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-real-time-output-streaming/04-RESEARCH.md
@.planning/phases/04-real-time-output-streaming/04-01-SUMMARY.md
@packages/client/src/features/execution/ExecutionPanel.tsx
@packages/client/src/features/execution/executionApi.ts
@packages/client/src/pages/Home.tsx
@packages/shared/src/types/streaming.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: useSSE hook, ConsoleView component with ANSI support, and ExecutionPanel streaming integration</name>
  <files>
    packages/client/src/hooks/useSSE.ts
    packages/client/src/features/execution/ConsoleView.tsx
    packages/client/src/features/execution/ExecutionPanel.tsx
    packages/client/src/features/execution/executionApi.ts
    packages/client/package.json
  </files>
  <action>
    1. Install ansi_up on client: `npm install ansi_up -w @repo/client`

    2. Create `packages/client/src/hooks/useSSE.ts`:
       - Custom React hook: `useSSE(jobId: string | null, callbacks: { onOutput?: (line: string) => void; onComplete?: (result: ExecutionResponse) => void; onError?: (error: Event) => void })`
       - Returns `{ connectionState: 'idle' | 'connecting' | 'connected' | 'closed' | 'error' }`
       - Inside useEffect (dependency: [jobId]):
         a. If jobId is null, return early (no connection)
         b. Set connectionState to 'connecting'
         c. Create `new EventSource(`/api/stream/${jobId}`)`
         d. onopen: set connectionState to 'connected'
         e. addEventListener 'output': parse JSON data, extract `line`, call `callbacks.onOutput?.(line)`
         f. addEventListener 'complete': parse JSON data as ExecutionResponse, call `callbacks.onComplete?.(result)`, close EventSource, set state 'closed'
         g. addEventListener 'error' (SSE event, not onerror): parse JSON data, call `callbacks.onError?.(data)`, close EventSource, set state 'error'
         h. onerror (connection error): call `callbacks.onError?.(error)`, close EventSource, set state 'error'
         i. Cleanup function: if eventSource.readyState !== EventSource.CLOSED, close it
       - IMPORTANT: Store callbacks in a ref (useRef) to avoid EventSource recreation on every callback change. Only recreate EventSource when jobId changes.
       - Type EventSource event.data as string, parse with JSON.parse

    3. Create `packages/client/src/features/execution/ConsoleView.tsx`:
       - Props: `{ lines: string[]; isStreaming: boolean }`
       - Create AnsiUp instance at module level (singleton): `const ansiUp = new AnsiUp(); ansiUp.escape_html = true;`
       - Use useRef for container div (for auto-scroll)
       - Use useEffect to auto-scroll: when lines change, set `containerRef.current.scrollTop = containerRef.current.scrollHeight`
       - Convert all lines to HTML: `const html = ansiUp.ansi_to_html(lines.join('\n'))`
       - Render in `<pre>` with `dangerouslySetInnerHTML={{ __html: html }}` (safe because escape_html=true prevents XSS)
       - Styling: `bg-zinc-900 text-zinc-100 p-4 rounded-lg overflow-y-auto max-h-[400px] text-xs font-mono leading-relaxed`
       - When `isStreaming` is true, show a blinking cursor indicator at the bottom (a small pulsing block or underscore via CSS animation)
       - Empty state: if no lines, show "Waiting for output..." in muted text
       - Line count indicator: show `{lines.length} lines` in a subtle footer

    4. Update `packages/client/src/features/execution/ExecutionPanel.tsx`:
       - Import useSSE from '../../hooks/useSSE'
       - Import ConsoleView from './ConsoleView'
       - Add state: `const [jobId, setJobId] = useState<string | null>(null)`
       - Add state: `const [outputLines, setOutputLines] = useState<string[]>([])`
       - Update ExecutionState type to: `'idle' | 'streaming' | 'complete'` (rename 'executing' to 'streaming' for clarity)
       - Wire useSSE hook:
         ```
         const { connectionState } = useSSE(jobId, {
           onOutput: (line) => setOutputLines((prev) => [...prev, line]),
           onComplete: (result) => {
             setExecutionResult(result);
             setExecutionState('complete');
             setJobId(null);
           },
           onError: () => {
             setExecutionError('Connection to execution stream lost. The tool may still be running.');
             setExecutionState('complete');
             setJobId(null);
           },
         });
         ```
       - Update handleRun:
         a. Reset: setOutputLines([]), setExecutionResult(null), setExecutionError(null)
         b. Set state to 'streaming'
         c. Call executeTool mutation (which now returns just { data: { jobId } })
         d. Extract jobId from response: `const { jobId: newJobId } = response.data`
         e. Set jobId state: `setJobId(newJobId)` (this triggers useSSE to connect)
         f. On error: set error message, set state to 'complete'
       - Update handleReset: also `setJobId(null)` and `setOutputLines([])`
       - Update UI rendering:
         a. During 'streaming' state: show ConsoleView with isStreaming=true, show connection state indicator, show QueueStatus
         b. Show a streaming status line: "Streaming output..." with a spinner and connection state badge (connecting/connected)
         c. During 'complete' state: show ConsoleView with isStreaming=false (if there are lines), show execution metrics (status badge, exit code, duration)
         d. The existing results section (status badge, exit code, duration, error display) stays for 'complete' state
         e. Remove the old `<pre>` block that showed `executionResult.output.join('\n')` - ConsoleView replaces it
       - Run button text: show "Running..." during 'streaming' (with spinner) instead of during 'executing'

    5. Update `packages/client/src/features/execution/executionApi.ts`:
       - The executeTool mutation response type changes from `{ data: ExecutionResponse }` to `{ data: { jobId: string } }`
       - Update the type: `builder.mutation<{ data: { jobId: string } }, ExecutionRequest>`
       - Everything else stays the same (baseQuery, URL, method, other endpoints)

    Build and verify: `npm run build` must pass with 0 errors.
  </action>
  <verify>
    Run `npm run build` from project root - must compile with 0 errors.
    Run `npx eslint packages/client/src --ext .ts,.tsx` - must pass with 0 errors.
  </verify>
  <done>
    - ansi_up installed in client package.json
    - useSSE hook manages EventSource lifecycle with connection state tracking
    - ConsoleView renders ANSI-colored output with auto-scroll and streaming indicator
    - ExecutionPanel uses two-phase flow: submit job -> connect SSE -> stream output -> show results
    - executionApi mutation type updated for jobId-only response
    - TypeScript builds cleanly, ESLint clean
  </done>
</task>

<task type="auto">
  <name>Task 2: Tests for useSSE hook, ConsoleView, and updated ExecutionPanel</name>
  <files>
    packages/client/src/__tests__/useSSE.test.tsx
    packages/client/src/__tests__/ConsoleView.test.tsx
    packages/client/src/__tests__/ExecutionPanel.test.tsx
  </files>
  <action>
    1. Install event-source-mock for testing: `npm install -D @dimak.dev/event-source-mock -w @repo/client`

    2. Create `packages/client/src/__tests__/useSSE.test.tsx`:
       - Import EventSourceMock from '@dimak.dev/event-source-mock' (or manually mock EventSource if the library has compatibility issues)
       - Set `global.EventSource = EventSourceMock` (or equivalent mock) before tests
       - Test "returns idle state when jobId is null":
         Render hook with null jobId, verify connectionState is 'idle'
       - Test "creates EventSource when jobId is provided":
         Render hook with 'test-job-id', verify EventSource was constructed with '/api/stream/test-job-id'
       - Test "calls onOutput when output event received":
         Render hook, simulate output event with `{ data: JSON.stringify({ line: 'hello world', timestamp: 123 }) }`, verify onOutput was called with 'hello world'
       - Test "calls onComplete when complete event received":
         Render hook, simulate complete event with mock ExecutionResponse data, verify onComplete was called with the result
       - Test "closes EventSource on complete event":
         Render hook, simulate complete event, verify eventSource.close() was called
       - Test "closes EventSource on unmount cleanup":
         Render hook with jobId, unmount, verify close was called
       - If @dimak.dev/event-source-mock doesn't work well with the test environment, create a minimal mock:
         ```
         class MockEventSource {
           static instances: MockEventSource[] = [];
           readyState = 0;
           listeners: Record<string, Function[]> = {};
           onopen: Function | null = null;
           onerror: Function | null = null;
           url: string;
           constructor(url: string) { this.url = url; MockEventSource.instances.push(this); }
           addEventListener(event: string, fn: Function) { (this.listeners[event] ||= []).push(fn); }
           close() { this.readyState = 2; }
           // Helper for tests:
           emit(event: string, data: any) { this.listeners[event]?.forEach(fn => fn(data)); }
         }
         ```

    3. Create `packages/client/src/__tests__/ConsoleView.test.tsx`:
       - Test "renders output lines":
         Render ConsoleView with lines=['line 1', 'line 2'], verify both appear in DOM
       - Test "shows waiting message when no lines":
         Render with empty lines array, verify "Waiting for output..." text
       - Test "shows streaming indicator when isStreaming is true":
         Render with isStreaming=true and some lines, verify streaming cursor/indicator is visible
       - Test "shows line count":
         Render with 5 lines, verify "5 lines" appears
       - Test "converts ANSI codes to colored HTML" (if testable):
         Render with lines containing ANSI escape codes like '\x1b[31mred text\x1b[0m', verify the output contains colored HTML (check for `<span` with style attribute) OR just verify the raw escape codes don't appear as text

    4. Update `packages/client/src/__tests__/ExecutionPanel.test.tsx`:
       - Update existing tests to account for the new streaming flow:
         a. The executeTool mutation now returns `{ data: { jobId: 'test-uuid' } }` instead of `{ data: fullExecutionResponse }`
         b. Mock useSSE hook or mock EventSource globally
       - Test "shows streaming console during execution":
         Mock executeTool to return jobId, verify ConsoleView appears after clicking Run
       - Test "shows execution metrics after completion":
         Mock complete flow (submit -> stream -> complete), verify status badge, exit code, duration displayed
       - Test "disabled states remain correct":
         Keep existing tests for disabled button when no projectId or no selectedToolId
       - Mock the SSE connection in tests. Either:
         a. Mock the useSSE module: `vi.mock('../../hooks/useSSE', () => ({ useSSE: vi.fn(() => ({ connectionState: 'idle' })) }))`
         b. Or mock global EventSource and simulate events
       - Use the simpler approach (module mock) to avoid test complexity

    Run all client tests: `npm test --workspace=@repo/client` must pass.
    Run ESLint: must pass with 0 errors.
  </action>
  <verify>
    Run `npm test --workspace=@repo/client` - all tests pass (existing + new).
    Run `npx eslint packages/client/src --ext .ts,.tsx` - 0 errors.
    Run `npm run build` - full build passes.
  </verify>
  <done>
    - useSSE hook tests cover: idle state, EventSource creation, output/complete/error events, cleanup on unmount
    - ConsoleView tests cover: line rendering, empty state, streaming indicator, ANSI handling
    - ExecutionPanel tests updated for streaming flow (jobId response, ConsoleView integration)
    - All client tests pass
    - All server tests still pass
    - ESLint clean, TypeScript build clean
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes with 0 TypeScript errors across all packages
2. `npm test --workspace=@repo/client` passes all tests
3. `npm test --workspace=@repo/server` passes all tests (verify no regressions)
4. `npx eslint packages/client/src --ext .ts,.tsx` passes with 0 errors
5. Full integration test (if dev server running): Upload a project, select a tool, click Run, see streaming output appear line-by-line in ConsoleView with ANSI colors, see execution metrics after completion
</verification>

<success_criteria>
- User sees output lines streaming in real-time in ConsoleView as tool executes
- ANSI color codes rendered as colored HTML (not raw escape sequences)
- Console auto-scrolls to bottom as new lines arrive
- Streaming indicator visible during execution
- Execution metrics (status, exit code, duration) displayed after completion
- EventSource properly cleaned up on unmount/completion
- All tests pass, TypeScript and ESLint clean
</success_criteria>

<output>
After completion, create `.planning/phases/04-real-time-output-streaming/04-02-SUMMARY.md`
</output>
