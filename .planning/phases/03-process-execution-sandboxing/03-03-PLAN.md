---
phase: 03-process-execution-sandboxing
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - packages/client/src/features/execution/executionApi.ts
  - packages/client/src/features/execution/ToolPicker.tsx
  - packages/client/src/features/execution/ExecutionPanel.tsx
  - packages/client/src/features/execution/QueueStatus.tsx
  - packages/client/src/store/index.ts
  - packages/client/src/pages/Home.tsx
  - packages/client/src/__tests__/ToolPicker.test.tsx
  - packages/client/src/__tests__/ExecutionPanel.test.tsx
autonomous: true

must_haves:
  truths:
    - "User can select which tool to run from clear picker showing all 8 tools"
    - "Each tool displays accurate status badge (Available / In Development / Coming Soon)"
    - "User sees queue position and estimated wait time when at capacity"
  artifacts:
    - path: "packages/client/src/features/execution/ToolPicker.tsx"
      provides: "Tool selection UI showing all 8 tools with status badges"
      min_lines: 60
    - path: "packages/client/src/features/execution/ExecutionPanel.tsx"
      provides: "Execution trigger and result display panel"
      min_lines: 80
    - path: "packages/client/src/features/execution/QueueStatus.tsx"
      provides: "Queue position and wait time display"
      min_lines: 30
    - path: "packages/client/src/features/execution/executionApi.ts"
      provides: "RTK Query API for execution and queue status"
      exports: ["executionApi", "useExecuteToolMutation", "useGetQueueStatusQuery", "useGetToolsQuery"]
  key_links:
    - from: "packages/client/src/features/execution/ExecutionPanel.tsx"
      to: "packages/client/src/features/execution/executionApi.ts"
      via: "useExecuteToolMutation hook"
      pattern: "useExecuteToolMutation"
    - from: "packages/client/src/features/execution/ToolPicker.tsx"
      to: "packages/shared/src/constants/tools.ts"
      via: "TOOLS array for tool list"
      pattern: "import.*TOOLS.*from.*@repo/shared"
    - from: "packages/client/src/features/execution/executionApi.ts"
      to: "/api/execute"
      via: "RTK Query fetch to execute endpoint"
      pattern: "url.*execute"
    - from: "packages/client/src/store/index.ts"
      to: "packages/client/src/features/execution/executionApi.ts"
      via: "Redux store registration"
      pattern: "executionApi"
    - from: "packages/client/src/pages/Home.tsx"
      to: "packages/client/src/features/execution/ExecutionPanel.tsx"
      via: "Component composition"
      pattern: "ExecutionPanel"
---

<objective>
Build the client-side tool picker and execution UI: tool selection showing all 8 tools with status badges, execution trigger, queue status display, and result output panel.

Purpose: This plan delivers the user-facing experience for Phase 3. Users need to see all tools, understand which are available, select one to run against their uploaded project, and see execution results. Without this, the server execution engine (Plan 01+02) has no frontend.

Output: ToolPicker component showing all 8 tools with status badges (Available/In Development/Coming Soon). ExecutionPanel that triggers execution and displays results. QueueStatus showing position and estimated wait. All wired into the Home page after the upload zone.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-process-execution-sandboxing/03-01-SUMMARY.md
@.planning/phases/03-process-execution-sandboxing/03-02-SUMMARY.md

@packages/shared/src/types/tool.ts
@packages/shared/src/types/execution.ts
@packages/shared/src/constants/tools.ts
@packages/client/src/features/upload/UploadZone.tsx
@packages/client/src/features/upload/uploadApi.ts
@packages/client/src/store/index.ts
@packages/client/src/pages/Home.tsx
@packages/client/src/components/ui/button.tsx
@packages/client/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Execution RTK Query API and ToolPicker component with status badges</name>
  <files>
    packages/client/src/features/execution/executionApi.ts
    packages/client/src/features/execution/ToolPicker.tsx
    packages/client/src/features/execution/QueueStatus.tsx
    packages/client/src/store/index.ts
  </files>
  <action>
    **1. Create execution API** (`packages/client/src/features/execution/executionApi.ts`):
    - Import `createApi, fetchBaseQuery` from `@reduxjs/toolkit/query/react`
    - Import `ExecutionRequest, ExecutionResponse, QueueStatus, Tool` from `@repo/shared`
    - Create `executionApi = createApi({...})`:
      - `reducerPath: 'executionApi'`
      - `baseQuery: fetchBaseQuery({ baseUrl: '/api' })`
      - Endpoints:
        - `executeTool`: mutation `<{ data: ExecutionResponse }, ExecutionRequest>` -- `POST /execute` with `{ toolId, projectId }` JSON body
        - `getQueueStatus`: query `<{ data: QueueStatus }, void>` -- `GET /queue/status`
        - `getTools`: query `<Tool[], void>` -- uses TOOLS constant from @repo/shared directly (no API call needed -- tools are static). Use `queryFn` that returns `{ data: TOOLS }` imported from `@repo/shared`
    - Export hooks: `useExecuteToolMutation`, `useGetQueueStatusQuery`, `useGetToolsQuery`

    **2. Register in Redux store** (`packages/client/src/store/index.ts`):
    - Import `executionApi` from `@/features/execution/executionApi`
    - Add `[executionApi.reducerPath]: executionApi.reducer` to reducer
    - Add `executionApi.middleware` to middleware chain
    - Keep existing healthApi and uploadApi registrations

    **3. Create ToolPicker component** (`packages/client/src/features/execution/ToolPicker.tsx`):
    - Import `TOOLS` from `@repo/shared`
    - Import `Tool, ToolStatus` from `@repo/shared`
    - Props: `{ selectedToolId: string | null; onSelectTool: (toolId: string) => void; disabled?: boolean }`
    - Render all 8 tools as clickable cards in a responsive grid (2 columns on md, 1 on mobile)
    - Each tool card shows:
      - Tool name (bold)
      - Tool description (muted text)
      - Source language -> Target language (if transpiler) or just source language
      - Status badge with color coding:
        - `available`: green badge "Available" -- card is clickable
        - `in-development`: yellow/amber badge "In Development" -- card is clickable but dimmed
        - `coming-soon`: gray badge "Coming Soon" -- card is NOT clickable (disabled with opacity-50, cursor-not-allowed)
      - Selected state: highlighted border (border-primary, bg-primary/5)
    - Use Tailwind classes for styling. Use `clsx` for conditional classes (already in client dependencies).
    - Only tools with status !== 'coming-soon' should be selectable
    - When a tool is selected, call `onSelectTool(tool.id)`

    **4. Create QueueStatus component** (`packages/client/src/features/execution/QueueStatus.tsx`):
    - Import `useGetQueueStatusQuery` from `./executionApi`
    - Only renders when queue has pending/waiting jobs (position > 0 or pending > 0)
    - Polls queue status every 3 seconds: `useGetQueueStatusQuery(undefined, { pollingInterval: 3000 })`
    - Shows: "Queue: {position} waiting | {pending} running | Est. wait: {estimatedWaitSec}s"
    - Minimal styling: small text, info badge appearance
    - If queue is empty (position === 0 and pending < concurrency), show nothing (return null)
  </action>
  <verify>
    - `npm run build` passes with no TypeScript errors
    - `npx eslint packages/client/src/ packages/shared/src/` has no errors
    - Verify executionApi is registered in store: grep for executionApi in store/index.ts
    - Verify TOOLS array shows all 8 tools in ToolPicker
    - Verify status badge color mapping covers all 3 statuses
  </verify>
  <done>
    - Execution RTK Query API with executeTool mutation, getQueueStatus query, getTools query
    - ToolPicker component displays all 8 tools with status badges and selection state
    - QueueStatus component shows queue position and estimated wait with polling
    - Redux store updated with executionApi reducer and middleware
    - TypeScript build succeeds, ESLint clean
  </done>
</task>

<task type="auto">
  <name>Task 2: ExecutionPanel component, Home page integration, and tests</name>
  <files>
    packages/client/src/features/execution/ExecutionPanel.tsx
    packages/client/src/pages/Home.tsx
    packages/client/src/__tests__/ToolPicker.test.tsx
    packages/client/src/__tests__/ExecutionPanel.test.tsx
  </files>
  <action>
    **1. Create ExecutionPanel component** (`packages/client/src/features/execution/ExecutionPanel.tsx`):
    - This is the main execution workflow component that composes ToolPicker, QueueStatus, and execution results
    - Props: `{ projectId: string | null }` -- comes from successful upload
    - Internal state:
      - `selectedToolId: string | null` -- which tool is selected
    - Import `useExecuteToolMutation` from `./executionApi`
    - Import `ToolPicker` from `./ToolPicker`
    - Import `QueueStatus` from `./QueueStatus`
    - Import `Button` from `@/components/ui/button`
    - Layout:
      1. **Tool selection section**: `<ToolPicker>` component -- always visible
      2. **Run button**: "Run {toolName}" button -- enabled only when both projectId AND selectedToolId are set. Disabled with helpful tooltip text: "Upload a project first" if no projectId, "Select a tool" if no tool selected
      3. **Queue status**: `<QueueStatus />` -- shown during/before execution
      4. **Execution result section** (visible after execution completes):
        - Status indicator: colored badge showing 'completed' (green), 'failed' (red), 'timeout' (amber), 'cancelled' (gray)
        - Exit code display
        - Duration display (formatted as "X.Xs")
        - Output display: monospace pre block with scrollable output showing all returned output lines. Max height 400px with overflow-y-auto. Dark background (bg-zinc-900 text-zinc-100) for console appearance.
        - If error message present, show in red text above output
      5. **Run another button**: "Run Again" to re-execute, "Reset" to clear results
    - State machine for execution flow:
      - `idle`: ToolPicker shown, Run button available (if conditions met)
      - `executing`: Spinner + "Running {toolName}..." + QueueStatus shown, Run button disabled
      - `complete`: Results shown with status badge + output + metrics
    - Handle execution errors (network errors, 429 rate limited) with user-friendly messages:
      - 429: "Rate limit exceeded. Please wait before trying again."
      - Network error: "Connection failed. Please check your connection."
      - Other: Show error message from server

    **2. Update Home page** (`packages/client/src/pages/Home.tsx`):
    - Import `ExecutionPanel` from `@/features/execution/ExecutionPanel`
    - Add state: `const [projectId, setProjectId] = useState<string | null>(null)`
    - Pass `onUploadSuccess={setProjectId}` to `<UploadZone />`
    - Add execution section below the upload zone:
      ```tsx
      <div className="pt-8 space-y-4">
        <h2 className="text-2xl font-semibold">Run a Tool</h2>
        <ExecutionPanel projectId={projectId} />
      </div>
      ```
    - The execution panel is always visible (tools browsable even before upload), but the Run button is disabled until a project is uploaded

    **3. Write ToolPicker tests** (`packages/client/src/__tests__/ToolPicker.test.tsx`):
    - Use vitest + @testing-library/react
    - Test: renders all 8 tool names
    - Test: renders status badges with correct text (Available, In Development, Coming Soon)
    - Test: clicking an available tool calls onSelectTool
    - Test: coming-soon tools are not clickable (disabled state)
    - Test: selected tool has highlighted styling
    - Minimum 4 tests

    **4. Write ExecutionPanel tests** (`packages/client/src/__tests__/ExecutionPanel.test.tsx`):
    - Use vitest + @testing-library/react
    - Wrap components in Redux Provider with test store
    - Test: renders Run button disabled when no projectId
    - Test: renders Run button disabled when no tool selected
    - Test: renders tool picker section
    - Test: shows execution results after mock mutation completes (mock executionApi)
    - Minimum 3 tests
  </action>
  <verify>
    - `npm run build` passes with no TypeScript errors
    - `npm test -w @repo/client` passes all existing + new tests
    - `npx eslint packages/client/src/` has no errors
    - Verify Home.tsx imports and renders ExecutionPanel
    - Verify ToolPicker shows all 8 tools
    - Verify ExecutionPanel has Run button with correct disabled states
    - ToolPicker.test.tsx has >= 4 tests
    - ExecutionPanel.test.tsx has >= 3 tests
  </verify>
  <done>
    - ExecutionPanel component manages full execution workflow: tool selection -> run -> results
    - Home page integrates ExecutionPanel below upload zone with projectId state flow
    - Tool picker shows all 8 tools with correct status badges and selection behavior
    - Execution results display: status badge, exit code, duration, scrollable console output
    - Run button disabled until both project uploaded and tool selected
    - Queue status shown during execution with polling
    - All tests pass (existing + 7+ new client tests), build succeeds, ESLint clean
  </done>
</task>

</tasks>

<verification>
1. `npm run build` -- full project (client + server + shared) compiles without errors
2. `npm test -w @repo/client` -- all client tests pass (existing + new ToolPicker/ExecutionPanel tests)
3. `npx eslint packages/client/src/` -- zero errors
4. ToolPicker renders all 8 tools with status badges
5. ExecutionPanel handles idle -> executing -> complete state transitions
6. Home page shows upload zone + execution panel with projectId flow
7. Queue status polls and displays when queue is busy
</verification>

<success_criteria>
- User can see all 8 tools in the tool picker with correct status badges (EXEC-01, EXEC-02)
- User can select an available tool and click Run to execute against their uploaded project
- User sees queue position and estimated wait time when at capacity (EXEC-07)
- User sees execution results: status, exit code, duration, console output
- Run button properly gated on both upload + tool selection
- All tests pass (expect 10+ total client tests), build succeeds, ESLint clean
</success_criteria>

<output>
After completion, create `.planning/phases/03-process-execution-sandboxing/03-03-SUMMARY.md`
</output>
