---
phase: 03-process-execution-sandboxing
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - packages/server/src/services/executionService.ts
  - packages/server/src/routes/execute.ts
  - packages/server/src/index.ts
  - packages/server/package.json
  - packages/server/src/__tests__/executionService.test.ts
  - packages/server/src/__tests__/execute.test.ts
  - docker-compose.yml
  - Dockerfile
autonomous: true

must_haves:
  truths:
    - "Server enforces per-process resource limits (60s timeout, cleanup on crash)"
    - "CLI tools execute via execa with zombie prevention and automatic cleanup"
    - "CLI tools run in strict sandboxes with no network access and read-only filesystems"
    - "Server handles 5-20 simultaneous users without degradation"
  artifacts:
    - path: "packages/server/src/services/executionService.ts"
      provides: "CLI tool execution with execa, timeout, cleanup"
      exports: ["ExecutionService", "executionService"]
      min_lines: 80
    - path: "packages/server/src/routes/execute.ts"
      provides: "POST /api/execute endpoint and GET /api/queue/status endpoint"
      exports: ["default"]
      min_lines: 60
    - path: "docker-compose.yml"
      provides: "Docker security hardening (no-new-privileges, cap_drop, read-only, resource limits)"
      contains: "no-new-privileges"
    - path: "Dockerfile"
      provides: "Production image with examples directory and uploads directory"
      contains: "examples"
  key_links:
    - from: "packages/server/src/routes/execute.ts"
      to: "packages/server/src/services/executionService.ts"
      via: "executionService.executeJob()"
      pattern: "executionService\\.execute"
    - from: "packages/server/src/routes/execute.ts"
      to: "packages/server/src/services/queueService.ts"
      via: "queueService.addJob()"
      pattern: "queueService\\.addJob"
    - from: "packages/server/src/routes/execute.ts"
      to: "packages/server/src/middleware/rateLimiter.ts"
      via: "Express middleware chain"
      pattern: "hourlyRateLimit|concurrentExecutionLimit"
    - from: "packages/server/src/services/executionService.ts"
      to: "execa"
      via: "Process spawning with safeguards"
      pattern: "execa\\("
    - from: "packages/server/src/index.ts"
      to: "packages/server/src/routes/execute.ts"
      via: "Express router registration"
      pattern: "app\\.use.*executeRouter"
---

<objective>
Wire up the execution engine: execution service (execa with timeout/cleanup), execute route (POST /api/execute + GET /api/queue/status), route registration, Docker security hardening, and comprehensive tests.

Purpose: This plan connects the infrastructure from Plan 01 (types, queue, rate limiter) into a working execution endpoint. After this plan, the server can accept tool execution requests, queue them, run CLI tools safely, and return results. Docker is hardened for production sandboxing.

Output: Working POST /api/execute endpoint accepting {toolId, projectId}, running CLI tools via execa with 60s timeout and zombie prevention, returning ExecutionResponse. GET /api/queue/status for monitoring. Docker hardened with capability dropping, no-new-privileges, read-only filesystem, and resource limits.
</objective>

<execution_context>
@/Users/alexanderfedin/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexanderfedin/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-process-execution-sandboxing/03-RESEARCH.md
@.planning/phases/03-process-execution-sandboxing/03-01-SUMMARY.md

@packages/shared/src/types/execution.ts
@packages/shared/src/types/tool.ts
@packages/server/src/config/limits.ts
@packages/server/src/config/toolRegistry.ts
@packages/server/src/services/queueService.ts
@packages/server/src/middleware/rateLimiter.ts
@packages/server/src/services/projectService.ts
@packages/server/src/types/errors.ts
@packages/server/src/index.ts
@packages/server/src/routes/upload.ts
@packages/server/package.json
@docker-compose.yml
@Dockerfile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Execution service with execa and execute route with queue integration</name>
  <files>
    packages/server/src/services/executionService.ts
    packages/server/src/routes/execute.ts
    packages/server/src/index.ts
    packages/server/package.json
  </files>
  <action>
    **1. Install execa:**
    - Run `npm install execa -w @repo/server`
    - execa v9 is ESM-only -- compatible with our ESM project (type: "module")

    **2. Create execution service** (`packages/server/src/services/executionService.ts`):
    - Import `execa` from `execa`
    - Import `ExecutionResponse, ToolExecutionConfig` from `@repo/shared`
    - Import `getToolConfig` from `../config/toolRegistry.js`
    - Import `EXECUTION_LIMITS` from `../config/limits.js`
    - Import `NotFoundError, UserError` from `../types/errors.js`
    - Import `stat` from `fs/promises` for path existence check
    - Class `ExecutionService`:
      - `async executeJob(params: { toolId: string; projectPath: string; jobId: string; onOutput?: (line: string) => void }): Promise<ExecutionResponse>`
      - **Validate tool**: `getToolConfig(toolId)` -- throw `NotFoundError('Tool')` if undefined, throw `UserError('Tool is not available', 400)` if available === false
      - **Validate path**: `stat(projectPath)` -- throw `NotFoundError('Project directory')` if ENOENT
      - **Record timing**: `startedAt = new Date().toISOString()`
      - **Execute**: `execa(config.command, [...config.defaultArgs, projectPath], { cwd: projectPath, timeout: config.maxExecutionTimeMs, killSignal: 'SIGTERM', cleanup: true, reject: false, all: true, buffer: false })`
        - NEVER use `shell: true`
        - NEVER interpolate user input into command strings
      - **Stream output**: `for await (const line of subprocess.all)` -- call `params.onOutput?.(line)`, accumulate into `output: string[]` capped at `EXECUTION_LIMITS.maxOutputLines`
      - **Determine status from result**:
        - `result.timedOut === true` -> status = 'timeout'
        - `result.killed === true && !result.timedOut` -> status = 'cancelled'
        - `result.exitCode === 0` -> status = 'completed'
        - else -> status = 'failed'
      - **Return ExecutionResponse**: `{ jobId, status, exitCode: result.exitCode ?? -1, output, startedAt, completedAt: new Date().toISOString(), durationMs: Date.now() - start }`
      - If any error in subprocess.all iteration, set status = 'failed', include error message
    - Export singleton `executionService = new ExecutionService()`

    **3. Create execute route** (`packages/server/src/routes/execute.ts`):
    - Import Router from express
    - Import `ExecutionRequest` from `@repo/shared`
    - Import `ValidationError` from `../types/errors.js`
    - Import `executionService` from `../services/executionService.js`
    - Import `queueService` from `../services/queueService.js`
    - Import `hourlyRateLimit, concurrentExecutionLimit` from `../middleware/rateLimiter.js`
    - Import `v4 as uuidv4` from `uuid`
    - Import `ProjectService` from `../services/projectService.js`
    - Import `config` from `../config/env.js`
    - Use lazy projectService initialization (same pattern as upload.ts) for test compatibility:
      ```
      let projectService: ProjectService | null = null;
      function getProjectService() {
        if (!projectService) {
          projectService = new ProjectService(process.env.UPLOAD_DIR || config.uploadDir);
        }
        return projectService;
      }
      ```
    - `POST /execute` with middleware chain `[hourlyRateLimit, concurrentExecutionLimit]`:
      - Parse body as `ExecutionRequest`
      - Validate: `toolId` must be non-empty string, `projectId` must be non-empty string -- throw `ValidationError` if missing
      - Resolve `projectPath` via `getProjectService().getProjectPath(projectId)`
      - Generate `jobId = uuidv4()`
      - Execute via queue: `const result = await queueService.addJob(() => executionService.executeJob({ toolId, projectPath, jobId }))`
      - Return `res.json({ data: result })`
      - Note: This is synchronous request-response. Client POSTs, request blocks during execution (up to 60s), returns result. Phase 4 adds SSE streaming for real-time output.
    - `GET /queue/status`:
      - No rate limiting (lightweight read)
      - Return `res.json({ data: queueService.getQueueStatus() })`

    **4. Register execute route** (`packages/server/src/index.ts`):
    - Import `executeRouter` from `./routes/execute.js`
    - Add `app.use("/api", executeRouter)` after the examplesRouter line
    - Follow existing pattern exactly
  </action>
  <verify>
    - `npm run build` passes with no TypeScript errors
    - `npx eslint packages/server/src/ packages/shared/src/` has no errors
    - Verify executeRouter is registered in index.ts: grep for `executeRouter`
    - Verify execa is in package.json dependencies
  </verify>
  <done>
    - Execution service runs CLI tools via execa with 60s timeout, cleanup: true, zombie prevention, output streaming
    - Execute route accepts POST /api/execute with {toolId, projectId}, validates input, queues job, returns ExecutionResponse
    - GET /api/queue/status returns current queue status
    - Rate limiting middleware applied to execute endpoint
    - Route registered in Express app
  </done>
</task>

<task type="auto">
  <name>Task 2: Docker security hardening and comprehensive test suite</name>
  <files>
    docker-compose.yml
    Dockerfile
    packages/server/src/__tests__/executionService.test.ts
    packages/server/src/__tests__/execute.test.ts
  </files>
  <action>
    **1. Docker security hardening** (`docker-compose.yml`):
    - Add under `app` service:
      ```yaml
      security_opt:
        - no-new-privileges:true
      cap_drop:
        - ALL
      read_only: true
      tmpfs:
        - /tmp
        - /app/uploads
      deploy:
        resources:
          limits:
            cpus: '4.0'
            memory: 1G
          reservations:
            cpus: '1.0'
            memory: 256M
      ```
    - Keep existing ports, env_file, restart, healthcheck config unchanged

    **2. Dockerfile production updates** (`Dockerfile`):
    - In the production stage, after copying dist artifacts:
      - Copy examples directory: `COPY --from=builder /app/packages/server/examples ./packages/server/examples`
      - Create uploads directory before USER switch: `RUN mkdir -p /app/uploads && chown nodejs:nodejs /app/uploads`
    - Keep everything else unchanged (multi-stage build, non-root user, healthcheck)

    **3. Write execution service tests** (`packages/server/src/__tests__/executionService.test.ts`):
    - Use vitest, follow existing test patterns
    - Mock `getToolConfig` from `../config/toolRegistry.js` using `vi.mock()` to avoid needing real tool binaries
    - For actual process execution tests, configure mock to return configs using system binaries:
      - Success test: `{ id: 'test-tool', command: 'echo', defaultArgs: ['hello world'], maxExecutionTimeMs: 5000, available: true }`
      - Timeout test: `{ id: 'test-tool', command: 'sleep', defaultArgs: ['10'], maxExecutionTimeMs: 500, available: true }` (500ms timeout with 10s sleep)
      - Failure test: `{ id: 'test-tool', command: 'node', defaultArgs: ['-e', 'process.exit(1)'], maxExecutionTimeMs: 5000, available: true }`
    - Create a temp directory for projectPath in beforeEach, clean up in afterEach
    - Tests:
      - Test successful execution: mock tool returning echo, verify status = 'completed', exitCode = 0, output contains expected text
      - Test timeout handling: mock tool with short timeout + sleep command, verify status = 'timeout'
      - Test non-zero exit code: mock tool with `process.exit(1)`, verify status = 'failed'
      - Test output line accumulation: mock tool with multi-line output, verify output array populated
      - Test unknown tool ID: call with 'nonexistent-tool', verify NotFoundError thrown
      - Test unavailable tool: mock getToolConfig returning `available: false`, verify UserError thrown
      - Test invalid project path: call with non-existent path, verify NotFoundError thrown
    - Minimum 6 tests

    **4. Write execute route tests** (`packages/server/src/__tests__/execute.test.ts`):
    - Use vitest + supertest, follow existing test patterns (see upload.test.ts, examples.test.ts)
    - Create test Express app with express-async-errors, executeRouter, errorHandler
    - Mock executionService.executeJob to avoid needing real tools -- return a canned ExecutionResponse
    - Mock projectService for path resolution -- use temp directory
    - Set env vars in beforeEach for test isolation
    - Tests:
      - Test POST /api/execute with valid {toolId, projectId} returns 200 with ExecutionResponse data
      - Test POST /api/execute with missing toolId returns 422
      - Test POST /api/execute with missing projectId returns 422
      - Test POST /api/execute with empty toolId returns 422
      - Test GET /api/queue/status returns 200 with queue status object (position, pending, concurrency, estimatedWaitMs, estimatedWaitSec)
    - Minimum 5 tests

    **5. Verify Docker build:**
    - Run `docker build -t test-build .` to confirm Dockerfile changes don't break the build
    - This is a verification step, not a deployment step
  </action>
  <verify>
    - `npm run build` passes with no TypeScript errors
    - `npm test -w @repo/server` passes all existing + new tests
    - `npx eslint packages/server/src/ packages/shared/src/` has no errors
    - `docker build -t test-build .` succeeds (Dockerfile changes valid)
    - executionService.test.ts has >= 6 tests covering success, timeout, failure, unknown tool, unavailable tool, bad path
    - execute.test.ts has >= 5 tests covering valid request, missing fields, queue status
    - docker-compose.yml contains: no-new-privileges, cap_drop ALL, read_only, tmpfs, deploy.resources
  </verify>
  <done>
    - Docker security hardened: no-new-privileges, all capabilities dropped, read-only root filesystem, tmpfs for temp/uploads, CPU/memory resource limits
    - Dockerfile copies examples to production image, creates owned uploads directory
    - Execution service tests cover: success, timeout, failure, output streaming, unknown tool, unavailable tool, bad path (7 tests)
    - Execute route tests cover: valid execution, missing fields, queue status (5 tests)
    - All tests pass (expect 70+ total server tests), build succeeds, Docker builds, ESLint clean
  </done>
</task>

</tasks>

<verification>
1. `npm run build` -- full project compiles without errors
2. `npm test -w @repo/server` -- all tests pass (existing + new execution/route tests)
3. `npx eslint packages/server/src/ packages/shared/src/` -- zero errors
4. `docker build -t test-build .` -- Docker image builds successfully
5. POST /api/execute route is registered and accepts requests
6. Rate limiter middleware applied to execute route
7. Execution service handles timeout, failure, success, cleanup correctly
8. Docker compose has all security hardening flags
</verification>

<success_criteria>
- POST /api/execute accepts {toolId, projectId}, queues via queueService, executes via execa, returns ExecutionResponse
- GET /api/queue/status returns current queue position, pending count, estimated wait time
- Execution service handles: timeout (status=timeout), failure (status=failed), success (status=completed), cancellation (status=cancelled)
- Docker container hardened with no-new-privileges, dropped capabilities, read-only root, resource limits (4 CPU, 1G memory)
- All tests pass (expect 70+ total server tests), Docker builds, ESLint clean
</success_criteria>

<output>
After completion, create `.planning/phases/03-process-execution-sandboxing/03-02-SUMMARY.md`
</output>
